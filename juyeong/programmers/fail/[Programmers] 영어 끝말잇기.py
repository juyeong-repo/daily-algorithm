# Link : https://school.programmers.co.kr/learn/courses/30/lessons/12981
"""
[제한조건]
n은 2이상 , 10이하 -> 반복문을 돌려도 시간 복잡도가 높지 않다
상수항만큼만 돈다

[예외]
탈락자가 생기지 않는다면 [0,0] 리턴
"""


"""
enumerate를 사용하면 좋을 것 같다. 예를 들어 
    Q. 정수 num과 k가 매개변수로 주어질 때, num을 이루는 숫자 중에 k가 있으면 num의 그 숫자가 있는 자리 수를 return하고 
    없으면 -1을 return 하도록 solution 함수를 완성해보세요.
이 문제처럼 사람을 인덱스로 하고 단어를 n으로 치환하여 반복문을 돌린다면? 

list.append
set.add (성능 더 좋음.. 일반적으로)
"""

def solution(n, words):
    '''
    1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.
    마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.
    앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.
    이전에 등장했던 단어는 사용할 수 없습니다.
    한 글자인 단어는 인정되지 않습니다.
    '''
    
    #이미 말했는지?
    used = set() #리스트 = Linear 타임 소모 /set= Constant
    
    # idx = 몇번째 사람?
    for idx in range(len(words)): 
        # 잘 나오는지 확인 print (idx, word) 
    
        userNum = (idx % n) + 1
        # print (userNum, word)
        
        Turn = (idx // n ) + 1
        
        #  이전에 등장했던 단어는 사용할 수 없습니다 + 한 글자인 단어는 인정되지 않습니다.
        if 1 < len(words[idx]) and words[idx] not in used:
            if idx == 0 : # 앞 사람이 말한 단어가 없는 경우
                used.add(words[idx])
            
            # 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.
            elif words[idx-1][-1] == words[idx][0]:
                used.add(words[idx])
            
            else:
                return [userNum, Turn]
        else: 
            return [userNum, Turn]
        
        #만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.
    return [0,0]



    """
    1.
    파이썬 리스트(List)는 해시 테이블과 달리 내부에서 해시 함수를 사용하지 않습니다. 
    파이썬 리스트는 연속된 메모리 공간에 요소를 저장하는 동적 배열(dynamic array)과 비슷한 구조를 가지고 있습니다.

    리스트의 각 요소는 메모리에 연속적으로 저장되며, 
    각 요소는 인덱스(0부터 시작)를 통해 접근할 수 있습니다. 
    이는 리스트가 요소를 검색하는 데 O(1)의 시간 복잡도를 가지는 이유입니다. 
    즉, 인덱스를 알고 있는 경우, 리스트에서 요소를 직접 접근하는 데 상수 시간이 걸립니다.

    그러나 리스트에는 내부적으로 해시 함수를 사용하지 않기 때문에 요소를 검색할 때 
    해시 테이블과 같은 O(1)의 시간 복잡도를 가지지 않습니다. 
    리스트에서 특정 요소를 찾으려면 리스트의 처음부터 끝까지 순차적으로 탐색해야 하며, 이러한 경우 **검색 시간은 O(n)이 됩니다.**

    따라서 리스트의 주요 작업인 인덱싱(인덱스를 통한 접근)은 빠르지만, 특
    정 요소를 검색하는 데는 효율성이 떨어집니다. 
    만약 특정 요소의 존재 여부를 빠르게 확인하려면 셋(Set)과 같은 다른 자료 구조를 고려해볼 수 있습니다.



    2.
    파이썬에서 해시 함수를 사용하는 주요 자료 구조는 다음과 같습니다:

    딕셔너리(Dictionary):
    파이썬의 딕셔너리는 해시 테이블을 기반으로 구현됩니다.
    딕셔너리는 키-값 쌍을 저장하며, 키를 사용하여 값을 검색하므로 키가 해시 함수를 사용하여 해싱되어 빠른 검색 속도를 제공합니다.
    딕셔너리의 키는 불변(immutable)해야 하므로 문자열, 정수, 튜플 등이 흔히 사용됩니다.
    
    셋(Set):
    파이썬의 셋은 해시 테이블을 기반으로 구현된 집합 자료 구조입니다.
    셋은 중복된 요소를 허용하지 않으며, 요소의 존재 여부를 빠르게 확인하기 위해 해시 함수를 사용합니다.
    셋은 중복 제거나 멤버십 테스트에 효과적으로 사용됩니다.
    
    frozenset:
    frozenset은 불변(immutable)한 셋입니다.
    frozenset 역시 해시 함수를 사용하여 해싱되므로 딕셔너리의 키 또는 다른 집합과 같이 해시 가능한(hashable) 객체로 사용될 수 있습니다.
    이러한 자료 구조들은 해시 함수를 사용하여 요소의 삽입, 삭제, 검색과 같은 작업을 효율적으로 수행할 수 있습니다. 
    해시 함수는 입력 데이터를 고정된 크기의 해시 코드로 변환하고, 이 코드를 사용하여 데이터를 저장하거나 검색하는 데 사용됩니다. 따라서 해시 함수를 사용하는 자료 구조들은 일반적으로 빠른 검색 및 멤버십 테스트를 제공하며, 데이터를 해시로 매핑하기 때문에 검색 시간이 입력 크기에 비례하지 않는 장점을 갖고 있습니다.



    출처: gpt
    
    결론: list -> linear, set -> constant로 set 승 (시간복잡도 측면)
    해시를 사용하는 것은 set
    list는 동적 배열 (배열의 크기가 1.25-언어별로 상이-씩 자동으로 증가하는 동적 배열!)




    """